"""
Executive ROI Report Generator
Translate technical security findings into business value

This module generates executive-level reports that quantify:
- Risk exposure and financial impact
- Cost-benefit analysis of security investments
- Security posture improvement tracking
- Compliance gap analysis
- Resource allocation recommendations
- Industry benchmark comparisons

Report Types:
- Executive Dashboard (KPIs)
- Board-Ready Summary
- Compliance Report (SOC 2, ISO 27001, PCI DSS)
- ROI Analysis
- Risk Quantification Report
- Remediation Prioritization

Author: Enterprise Scanner Security Team
Version: 1.0.0
"""

import json
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum


class RiskLevel(Enum):
    """Risk severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class ComplianceFramework(Enum):
    """Compliance frameworks"""
    SOC2 = "soc2"
    ISO27001 = "iso27001"
    PCI_DSS = "pci_dss"
    HIPAA = "hipaa"
    GDPR = "gdpr"
    CCPA = "ccpa"
    NIST = "nist"
    CDM = "cdm"


@dataclass
class SecurityFinding:
    """Individual security finding"""
    finding_id: str
    title: str
    description: str
    risk_level: RiskLevel
    cvss_score: float
    
    # Business impact
    affected_systems: int = 0
    affected_users: int = 0
    data_at_risk: str = "Unknown"
    
    # Financial impact
    potential_loss: float = 0.0  # In USD
    remediation_cost: float = 0.0
    
    # Compliance
    compliance_violations: List[ComplianceFramework] = field(default_factory=list)
    
    # Status
    discovered_date: datetime = field(default_factory=datetime.now)
    remediated: bool = False
    remediation_date: Optional[datetime] = None


@dataclass
class SecurityMetrics:
    """Security posture metrics"""
    # Vulnerability counts
    critical_vulns: int = 0
    high_vulns: int = 0
    medium_vulns: int = 0
    low_vulns: int = 0
    info_vulns: int = 0
    
    # Remediation
    vulnerabilities_fixed: int = 0
    mean_time_to_remediate: float = 0.0  # In days
    
    # Attack surface
    exposed_services: int = 0
    exploitable_vulnerabilities: int = 0
    
    # Compliance
    compliance_score: float = 0.0  # 0-100%
    controls_implemented: int = 0
    controls_required: int = 0
    
    # Security awareness
    phishing_success_rate: float = 0.0  # Percentage
    security_training_completion: float = 0.0  # Percentage
    
    # Timestamp
    assessed_date: datetime = field(default_factory=datetime.now)


@dataclass
class IndustryBenchmark:
    """Industry benchmark data"""
    industry: str
    avg_critical_vulns: int
    avg_high_vulns: int
    avg_breach_cost: float
    avg_time_to_detect: int  # Days
    avg_time_to_contain: int  # Days
    avg_phishing_success_rate: float  # Percentage


class ROIReportGenerator:
    """
    Executive ROI Report Generator
    
    Translates technical security findings into business value
    and executive-level insights.
    """
    
    def __init__(self):
        """Initialize ROI report generator"""
        self.findings: List[SecurityFinding] = []
        self.metrics_history: List[SecurityMetrics] = []
        
        # Industry benchmarks
        self.benchmarks = self._initialize_benchmarks()
        
        # Cost assumptions (configurable)
        self.avg_breach_cost = 4_240_000  # Average data breach cost (USD)
        self.avg_record_cost = 150  # Per record compromised
        self.avg_downtime_cost_per_hour = 5_000
        self.compliance_violation_cost = {
            ComplianceFramework.GDPR: 20_000_000,  # Up to €20M or 4% revenue
            ComplianceFramework.PCI_DSS: 500_000,  # Up to $500K
            ComplianceFramework.HIPAA: 50_000,  # Per violation
            ComplianceFramework.SOC2: 100_000,  # Remediation + audit
        }
    
    def _initialize_benchmarks(self) -> Dict[str, IndustryBenchmark]:
        """Initialize industry benchmark data"""
        
        return {
            'financial': IndustryBenchmark(
                industry='Financial Services',
                avg_critical_vulns=5,
                avg_high_vulns=15,
                avg_breach_cost=5_850_000,
                avg_time_to_detect=196,
                avg_time_to_contain=69,
                avg_phishing_success_rate=12
            ),
            'healthcare': IndustryBenchmark(
                industry='Healthcare',
                avg_critical_vulns=7,
                avg_high_vulns=20,
                avg_breach_cost=10_100_000,
                avg_time_to_detect=236,
                avg_time_to_contain=89,
                avg_phishing_success_rate=15
            ),
            'technology': IndustryBenchmark(
                industry='Technology',
                avg_critical_vulns=4,
                avg_high_vulns=12,
                avg_breach_cost=3_860_000,
                avg_time_to_detect=175,
                avg_time_to_contain=54,
                avg_phishing_success_rate=8
            ),
            'retail': IndustryBenchmark(
                industry='Retail',
                avg_critical_vulns=6,
                avg_high_vulns=18,
                avg_breach_cost=3_280_000,
                avg_time_to_detect=207,
                avg_time_to_contain=72,
                avg_phishing_success_rate=18
            )
        }
    
    def add_finding(self, finding: SecurityFinding) -> None:
        """Add security finding"""
        self.findings.append(finding)
    
    def add_metrics(self, metrics: SecurityMetrics) -> None:
        """Add security metrics snapshot"""
        self.metrics_history.append(metrics)
    
    def calculate_risk_exposure(self) -> Dict[str, Any]:
        """
        Calculate total risk exposure and potential financial impact.
        
        Returns:
            Dictionary with risk exposure metrics
        """
        
        total_potential_loss = 0.0
        compliance_risk = 0.0
        
        critical_count = 0
        high_count = 0
        exploitable_count = 0
        
        for finding in self.findings:
            if not finding.remediated:
                total_potential_loss += finding.potential_loss
                
                if finding.risk_level == RiskLevel.CRITICAL:
                    critical_count += 1
                elif finding.risk_level == RiskLevel.HIGH:
                    high_count += 1
                
                # Add compliance violation costs
                for framework in finding.compliance_violations:
                    if framework in self.compliance_violation_cost:
                        compliance_risk += self.compliance_violation_cost[framework]
                
                # Check if exploitable
                if finding.cvss_score >= 7.0:
                    exploitable_count += 1
        
        # Calculate aggregate risk score (0-100)
        risk_score = min(100, (critical_count * 20) + (high_count * 10) + (exploitable_count * 5))
        
        # Determine risk level
        if risk_score >= 70:
            risk_level = "CRITICAL"
        elif risk_score >= 50:
            risk_level = "HIGH"
        elif risk_score >= 30:
            risk_level = "MEDIUM"
        else:
            risk_level = "LOW"
        
        return {
            'risk_score': risk_score,
            'risk_level': risk_level,
            'total_potential_loss': total_potential_loss,
            'compliance_risk': compliance_risk,
            'total_risk_exposure': total_potential_loss + compliance_risk,
            'critical_findings': critical_count,
            'high_findings': high_count,
            'exploitable_vulnerabilities': exploitable_count,
            'unmitigated_findings': len([f for f in self.findings if not f.remediated])
        }
    
    def calculate_roi(self, investment_amount: float) -> Dict[str, Any]:
        """
        Calculate ROI of security investments.
        
        Args:
            investment_amount: Amount invested in security
            
        Returns:
            ROI analysis
        """
        
        risk_exposure = self.calculate_risk_exposure()
        
        # Calculate risk reduction (assume 80% reduction with proper investment)
        risk_reduction_rate = 0.80
        risk_mitigated = risk_exposure['total_risk_exposure'] * risk_reduction_rate
        
        # Calculate net benefit
        net_benefit = risk_mitigated - investment_amount
        
        # Calculate ROI percentage
        roi_percentage = (net_benefit / investment_amount * 100) if investment_amount > 0 else 0
        
        # Calculate payback period (months)
        monthly_risk = risk_exposure['total_risk_exposure'] / 12
        payback_months = (investment_amount / monthly_risk) if monthly_risk > 0 else float('inf')
        
        return {
            'investment_amount': investment_amount,
            'risk_mitigated': risk_mitigated,
            'net_benefit': net_benefit,
            'roi_percentage': roi_percentage,
            'payback_period_months': min(payback_months, 999),  # Cap at 999 months
            'break_even_point': investment_amount / (risk_mitigated / 12) if risk_mitigated > 0 else float('inf')
        }
    
    def calculate_security_posture_score(self) -> Dict[str, Any]:
        """
        Calculate overall security posture score (0-100).
        
        Returns:
            Security posture analysis
        """
        
        if not self.metrics_history:
            return {
                'posture_score': 0,
                'grade': 'F',
                'status': 'No metrics available'
            }
        
        # Get latest metrics
        latest = self.metrics_history[-1]
        
        # Calculate component scores
        vulnerability_score = self._score_vulnerabilities(latest)
        remediation_score = self._score_remediation(latest)
        compliance_score = latest.compliance_score
        awareness_score = self._score_awareness(latest)
        
        # Weighted average
        posture_score = (
            vulnerability_score * 0.35 +
            remediation_score * 0.25 +
            compliance_score * 0.25 +
            awareness_score * 0.15
        )
        
        # Assign grade
        if posture_score >= 90:
            grade = 'A'
            status = 'Excellent'
        elif posture_score >= 80:
            grade = 'B'
            status = 'Good'
        elif posture_score >= 70:
            grade = 'C'
            status = 'Fair'
        elif posture_score >= 60:
            grade = 'D'
            status = 'Poor'
        else:
            grade = 'F'
            status = 'Critical'
        
        return {
            'posture_score': round(posture_score, 1),
            'grade': grade,
            'status': status,
            'component_scores': {
                'vulnerability_management': round(vulnerability_score, 1),
                'remediation_effectiveness': round(remediation_score, 1),
                'compliance': round(compliance_score, 1),
                'security_awareness': round(awareness_score, 1)
            }
        }
    
    def _score_vulnerabilities(self, metrics: SecurityMetrics) -> float:
        """Score vulnerability management (0-100)"""
        
        total_vulns = (
            metrics.critical_vulns +
            metrics.high_vulns +
            metrics.medium_vulns +
            metrics.low_vulns
        )
        
        if total_vulns == 0:
            return 100.0
        
        # Weighted penalty for each severity
        penalty = (
            metrics.critical_vulns * 10 +
            metrics.high_vulns * 5 +
            metrics.medium_vulns * 2 +
            metrics.low_vulns * 0.5
        )
        
        score = max(0, 100 - penalty)
        return score
    
    def _score_remediation(self, metrics: SecurityMetrics) -> float:
        """Score remediation effectiveness (0-100)"""
        
        # Base score on mean time to remediate
        if metrics.mean_time_to_remediate == 0:
            return 100.0
        
        # Industry best practice: 30 days for critical, 90 days for others
        if metrics.mean_time_to_remediate <= 30:
            score = 100
        elif metrics.mean_time_to_remediate <= 60:
            score = 80
        elif metrics.mean_time_to_remediate <= 90:
            score = 60
        elif metrics.mean_time_to_remediate <= 180:
            score = 40
        else:
            score = 20
        
        return score
    
    def _score_awareness(self, metrics: SecurityMetrics) -> float:
        """Score security awareness (0-100)"""
        
        # Lower phishing success rate = higher score
        phishing_score = max(0, 100 - (metrics.phishing_success_rate * 3))
        
        # Higher training completion = higher score
        training_score = metrics.security_training_completion
        
        # Average
        awareness_score = (phishing_score + training_score) / 2
        return awareness_score
    
    def compare_to_industry(self, industry: str) -> Dict[str, Any]:
        """
        Compare security posture to industry benchmarks.
        
        Args:
            industry: Industry to compare against
            
        Returns:
            Comparison analysis
        """
        
        if industry not in self.benchmarks:
            return {'error': 'Industry not found'}
        
        benchmark = self.benchmarks[industry]
        
        if not self.metrics_history:
            return {'error': 'No metrics available'}
        
        latest = self.metrics_history[-1]
        
        # Calculate differences
        critical_diff = latest.critical_vulns - benchmark.avg_critical_vulns
        high_diff = latest.high_vulns - benchmark.avg_high_vulns
        phishing_diff = latest.phishing_success_rate - benchmark.avg_phishing_success_rate
        
        # Determine performance
        if critical_diff <= -2 and high_diff <= -5:
            performance = "ABOVE AVERAGE"
        elif critical_diff <= 0 and high_diff <= 0:
            performance = "AVERAGE"
        else:
            performance = "BELOW AVERAGE"
        
        return {
            'industry': benchmark.industry,
            'performance': performance,
            'comparison': {
                'critical_vulnerabilities': {
                    'company': latest.critical_vulns,
                    'industry_avg': benchmark.avg_critical_vulns,
                    'difference': critical_diff
                },
                'high_vulnerabilities': {
                    'company': latest.high_vulns,
                    'industry_avg': benchmark.avg_high_vulns,
                    'difference': high_diff
                },
                'phishing_success_rate': {
                    'company': latest.phishing_success_rate,
                    'industry_avg': benchmark.avg_phishing_success_rate,
                    'difference': phishing_diff
                }
            },
            'benchmark_data': {
                'avg_breach_cost': benchmark.avg_breach_cost,
                'avg_time_to_detect': benchmark.avg_time_to_detect,
                'avg_time_to_contain': benchmark.avg_time_to_contain
            }
        }
    
    def prioritize_remediation(self) -> List[Dict[str, Any]]:
        """
        Prioritize remediation efforts based on risk and impact.
        
        Returns:
            Prioritized list of findings
        """
        
        # Score each finding
        scored_findings = []
        for finding in self.findings:
            if finding.remediated:
                continue
            
            # Calculate priority score
            risk_weight = {
                RiskLevel.CRITICAL: 100,
                RiskLevel.HIGH: 75,
                RiskLevel.MEDIUM: 50,
                RiskLevel.LOW: 25,
                RiskLevel.INFO: 10
            }
            
            base_score = risk_weight.get(finding.risk_level, 0)
            
            # Adjust for business impact
            impact_multiplier = 1.0
            if finding.affected_users > 1000:
                impact_multiplier += 0.5
            if finding.affected_systems > 10:
                impact_multiplier += 0.3
            if finding.compliance_violations:
                impact_multiplier += 0.4
            
            # Adjust for financial impact
            if finding.potential_loss > 1_000_000:
                impact_multiplier += 0.5
            
            priority_score = base_score * impact_multiplier
            
            # Calculate cost-effectiveness (impact per dollar spent)
            cost_effectiveness = finding.potential_loss / finding.remediation_cost if finding.remediation_cost > 0 else 0
            
            scored_findings.append({
                'finding': finding,
                'priority_score': priority_score,
                'cost_effectiveness': cost_effectiveness,
                'roi': finding.potential_loss - finding.remediation_cost
            })
        
        # Sort by priority score (descending)
        scored_findings.sort(key=lambda x: x['priority_score'], reverse=True)
        
        return scored_findings
    
    def generate_executive_dashboard(self) -> Dict[str, Any]:
        """
        Generate executive dashboard with key metrics.
        
        Returns:
            Executive dashboard data
        """
        
        risk_exposure = self.calculate_risk_exposure()
        posture = self.calculate_security_posture_score()
        
        # Calculate trend (if we have history)
        trend = "STABLE"
        if len(self.metrics_history) >= 2:
            previous = self.metrics_history[-2]
            current = self.metrics_history[-1]
            
            prev_total = previous.critical_vulns + previous.high_vulns
            curr_total = current.critical_vulns + current.high_vulns
            
            if curr_total < prev_total * 0.8:
                trend = "IMPROVING"
            elif curr_total > prev_total * 1.2:
                trend = "DECLINING"
        
        dashboard = {
            'overview': {
                'security_posture_score': posture['posture_score'],
                'security_grade': posture['grade'],
                'risk_level': risk_exposure['risk_level'],
                'trend': trend
            },
            'key_metrics': {
                'total_risk_exposure': f"${risk_exposure['total_risk_exposure']:,.0f}",
                'critical_findings': risk_exposure['critical_findings'],
                'high_findings': risk_exposure['high_findings'],
                'unmitigated_findings': risk_exposure['unmitigated_findings']
            },
            'compliance': {
                'compliance_score': f"{self.metrics_history[-1].compliance_score:.1f}%" if self.metrics_history else "0%",
                'controls_implemented': self.metrics_history[-1].controls_implemented if self.metrics_history else 0,
                'controls_required': self.metrics_history[-1].controls_required if self.metrics_history else 0,
                'compliance_risk': f"${risk_exposure['compliance_risk']:,.0f}"
            },
            'recommendations': self._generate_executive_recommendations(risk_exposure, posture)
        }
        
        return dashboard
    
    def _generate_executive_recommendations(
        self,
        risk_exposure: Dict[str, Any],
        posture: Dict[str, Any]
    ) -> List[str]:
        """Generate executive-level recommendations"""
        
        recommendations = []
        
        if risk_exposure['risk_level'] in ['CRITICAL', 'HIGH']:
            recommendations.append("URGENT: Address critical security findings within 30 days")
        
        if risk_exposure['total_risk_exposure'] > 10_000_000:
            recommendations.append("Consider cyber insurance to transfer financial risk")
        
        if posture['posture_score'] < 70:
            recommendations.append("Increase security budget and resources to improve posture")
        
        if risk_exposure['compliance_risk'] > 1_000_000:
            recommendations.append("Prioritize compliance remediation to avoid regulatory penalties")
        
        if risk_exposure['exploitable_vulnerabilities'] > 10:
            recommendations.append("Deploy advanced threat detection and response capabilities")
        
        return recommendations
    
    def generate_board_report(self, company_name: str, industry: str) -> Dict[str, Any]:
        """
        Generate board-ready executive report.
        
        Args:
            company_name: Company name
            industry: Industry for benchmarking
            
        Returns:
            Comprehensive board report
        """
        
        dashboard = self.generate_executive_dashboard()
        risk_exposure = self.calculate_risk_exposure()
        posture = self.calculate_security_posture_score()
        roi = self.calculate_roi(investment_amount=500_000)  # Example investment
        benchmark = self.compare_to_industry(industry)
        priorities = self.prioritize_remediation()
        
        report = {
            'metadata': {
                'company': company_name,
                'report_date': datetime.now().strftime('%Y-%m-%d'),
                'report_type': 'Board-Level Security Assessment',
                'classification': 'CONFIDENTIAL'
            },
            'executive_summary': {
                'security_grade': posture['grade'],
                'security_posture_score': posture['posture_score'],
                'risk_level': risk_exposure['risk_level'],
                'total_risk_exposure': risk_exposure['total_risk_exposure'],
                'industry_performance': benchmark.get('performance', 'N/A'),
                'key_message': self._generate_key_message(posture, risk_exposure)
            },
            'financial_impact': {
                'potential_losses': risk_exposure['total_potential_loss'],
                'compliance_risk': risk_exposure['compliance_risk'],
                'total_exposure': risk_exposure['total_risk_exposure'],
                'recommended_investment': 500_000,
                'expected_roi': roi['roi_percentage'],
                'payback_period_months': roi['payback_period_months']
            },
            'security_metrics': dashboard['key_metrics'],
            'compliance_status': dashboard['compliance'],
            'industry_comparison': benchmark,
            'top_priorities': [
                {
                    'finding': p['finding'].title,
                    'risk': p['finding'].risk_level.value,
                    'cost_to_fix': f"${p['finding'].remediation_cost:,.0f}",
                    'potential_loss': f"${p['finding'].potential_loss:,.0f}",
                    'roi': f"${p['roi']:,.0f}"
                }
                for p in priorities[:5]  # Top 5
            ],
            'recommendations': dashboard['recommendations']
        }
        
        return report
    
    def _generate_key_message(
        self,
        posture: Dict[str, Any],
        risk_exposure: Dict[str, Any]
    ) -> str:
        """Generate key message for executives"""
        
        grade = posture['grade']
        risk_level = risk_exposure['risk_level']
        
        if grade in ['A', 'B'] and risk_level in ['LOW', 'MEDIUM']:
            return "Security posture is strong. Continue current investment levels."
        elif grade == 'C' or risk_level == 'HIGH':
            return "Security improvements needed. Recommend increased investment in remediation."
        else:
            return "CRITICAL: Immediate action required to address security deficiencies."


# Example usage
if __name__ == "__main__":
    # Initialize generator
    generator = ROIReportGenerator()
    
    print("\n" + "="*60)
    print("Executive ROI Report Generator")
    print("="*60 + "\n")
    
    # Add sample findings
    findings = [
        SecurityFinding(
            finding_id="VULN-001",
            title="Critical SQL Injection in Customer Portal",
            description="Unauthenticated SQL injection allows data exfiltration",
            risk_level=RiskLevel.CRITICAL,
            cvss_score=9.8,
            affected_systems=1,
            affected_users=50000,
            data_at_risk="Customer PII, payment data",
            potential_loss=2_500_000,
            remediation_cost=50_000,
            compliance_violations=[ComplianceFramework.PCI_DSS, ComplianceFramework.GDPR]
        ),
        SecurityFinding(
            finding_id="VULN-002",
            title="Unpatched Windows Servers",
            description="5 Windows servers missing critical security updates",
            risk_level=RiskLevel.HIGH,
            cvss_score=7.5,
            affected_systems=5,
            potential_loss=500_000,
            remediation_cost=10_000
        )
    ]
    
    for finding in findings:
        generator.add_finding(finding)
    
    # Add sample metrics
    metrics = SecurityMetrics(
        critical_vulns=2,
        high_vulns=8,
        medium_vulns=15,
        low_vulns=25,
        vulnerabilities_fixed=12,
        mean_time_to_remediate=45.0,
        compliance_score=78.5,
        controls_implemented=85,
        controls_required=100,
        phishing_success_rate=12.5,
        security_training_completion=85.0
    )
    
    generator.add_metrics(metrics)
    
    # Generate reports
    print("📊 Risk Exposure Analysis")
    print("="*60)
    risk = generator.calculate_risk_exposure()
    print(f"Risk Score: {risk['risk_score']}/100 ({risk['risk_level']})")
    print(f"Total Risk Exposure: ${risk['total_risk_exposure']:,.0f}")
    print(f"Critical Findings: {risk['critical_findings']}")
    print(f"High Findings: {risk['high_findings']}")
    
    print("\n💰 ROI Analysis")
    print("="*60)
    roi = generator.calculate_roi(500_000)
    print(f"Investment: ${roi['investment_amount']:,.0f}")
    print(f"Risk Mitigated: ${roi['risk_mitigated']:,.0f}")
    print(f"ROI: {roi['roi_percentage']:.1f}%")
    print(f"Payback Period: {roi['payback_period_months']:.1f} months")
    
    print("\n🎯 Security Posture Score")
    print("="*60)
    posture = generator.calculate_security_posture_score()
    print(f"Overall Score: {posture['posture_score']}/100 (Grade: {posture['grade']})")
    print(f"Status: {posture['status']}")
    
    print("\n📈 Industry Comparison")
    print("="*60)
    benchmark = generator.compare_to_industry('financial')
    print(f"Performance: {benchmark['performance']}")
    print(f"Critical Vulns: {benchmark['comparison']['critical_vulnerabilities']['company']} " +
          f"(Industry Avg: {benchmark['comparison']['critical_vulnerabilities']['industry_avg']})")
    
    print("\n🔝 Top Remediation Priorities")
    print("="*60)
    priorities = generator.prioritize_remediation()
    for i, p in enumerate(priorities[:3], 1):
        print(f"{i}. {p['finding'].title}")
        print(f"   Priority Score: {p['priority_score']:.1f}")
        print(f"   ROI: ${p['roi']:,.0f}")
    
    print("\n📋 Executive Dashboard")
    print("="*60)
    dashboard = generator.generate_executive_dashboard()
    print(json.dumps(dashboard, indent=2))
