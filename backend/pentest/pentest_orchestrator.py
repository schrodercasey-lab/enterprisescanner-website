"""
Penetration Testing Orchestration Layer
Unified automation for complete penetration testing workflow

This module orchestrates all penetration testing components:
- Credential management (vault)
- MITRE ATT&CK attack simulation
- Social engineering campaigns
- Executive ROI reporting
- Automated scheduling
- Results aggregation
- Notification system

Workflow:
1. Initialize test environment
2. Retrieve credentials from vault
3. Execute reconnaissance and attack chains
4. Launch social engineering campaigns
5. Aggregate and analyze results
6. Generate executive reports
7. Send notifications

Author: Enterprise Scanner Security Team
Version: 1.0.0
"""

import json
import asyncio
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import uuid

# Import pentest modules
try:
    from backend.pentest.credential_vault import CredentialVault, CredentialType, AccessLevel
    from backend.pentest.attack_chain_simulator import AttackSimulator, AttackTactic, APTGroup
    from backend.pentest.social_engineering_manager import SocialEngineeringManager, CampaignType
    from backend.pentest.roi_report_generator import ROIReportGenerator, SecurityFinding, SecurityMetrics, RiskLevel
except ImportError:
    # Fallback for standalone execution
    print("⚠️  Some modules not found - running in standalone mode")


class TestPhase(Enum):
    """Penetration test phases"""
    PLANNING = "planning"
    RECONNAISSANCE = "reconnaissance"
    WEAPONIZATION = "weaponization"
    DELIVERY = "delivery"
    EXPLOITATION = "exploitation"
    INSTALLATION = "installation"
    COMMAND_CONTROL = "command_control"
    ACTIONS_OBJECTIVES = "actions_objectives"
    REPORTING = "reporting"
    COMPLETED = "completed"


class TestStatus(Enum):
    """Test execution status"""
    SCHEDULED = "scheduled"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


@dataclass
class TestConfiguration:
    """Penetration test configuration"""
    test_id: str
    test_name: str
    
    # Scope
    target_networks: List[str] = field(default_factory=list)
    target_domains: List[str] = field(default_factory=list)
    target_applications: List[str] = field(default_factory=list)
    
    # Test types
    network_testing: bool = True
    web_app_testing: bool = True
    social_engineering: bool = True
    wireless_testing: bool = False
    physical_testing: bool = False
    
    # Attack simulation
    apt_group: str = "APT29"
    attack_tactics: List[str] = field(default_factory=list)
    
    # Social engineering
    phishing_enabled: bool = True
    phishing_targets: List[Dict[str, str]] = field(default_factory=list)
    
    # Scheduling
    scheduled_start: Optional[datetime] = None
    max_duration_hours: int = 24
    
    # Notifications
    notification_emails: List[str] = field(default_factory=list)
    
    # Compliance
    compliance_mode: bool = False
    compliance_frameworks: List[str] = field(default_factory=list)


@dataclass
class TestResults:
    """Aggregated test results"""
    test_id: str
    
    # Attack simulation results
    attack_chain_success_rate: float = 0.0
    attack_chain_detection_rate: float = 0.0
    techniques_executed: int = 0
    techniques_successful: int = 0
    
    # Social engineering results
    phishing_sent: int = 0
    phishing_opened: int = 0
    phishing_clicked: int = 0
    phishing_compromised: int = 0
    
    # Vulnerabilities discovered
    critical_vulns: int = 0
    high_vulns: int = 0
    medium_vulns: int = 0
    low_vulns: int = 0
    
    # Business impact
    systems_compromised: int = 0
    data_accessed: List[str] = field(default_factory=list)
    
    # Timeline
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    duration_minutes: float = 0.0


class PentestOrchestrator:
    """
    Penetration Testing Orchestration System
    
    Coordinates all penetration testing activities and
    provides unified workflow automation.
    """
    
    def __init__(
        self,
        vault_master_key: Optional[str] = None,
        gophish_url: Optional[str] = None,
        gophish_api_key: Optional[str] = None
    ):
        """
        Initialize orchestrator.
        
        Args:
            vault_master_key: Master key for credential vault
            gophish_url: Gophish server URL
            gophish_api_key: Gophish API key
        """
        self.test_configs: Dict[str, TestConfiguration] = {}
        self.test_results: Dict[str, TestResults] = {}
        self.active_tests: Dict[str, TestStatus] = {}
        
        # Initialize components
        try:
            self.vault = CredentialVault(master_key=vault_master_key or "default-master-key-change-me")
            self.attack_simulator = AttackSimulator()
            self.social_engineering = SocialEngineeringManager(gophish_url, gophish_api_key)
            self.roi_generator = ROIReportGenerator()
        except:
            print("⚠️  Running in standalone mode - some features unavailable")
            self.vault = None
            self.attack_simulator = None
            self.social_engineering = None
            self.roi_generator = None
        
        # Event handlers
        self.event_handlers: Dict[str, List[Callable]] = {
            'test_started': [],
            'test_completed': [],
            'phase_completed': [],
            'vulnerability_found': [],
            'compromise_detected': []
        }
    
    def create_test(self, config: TestConfiguration) -> str:
        """
        Create new penetration test.
        
        Args:
            config: Test configuration
            
        Returns:
            Test ID
        """
        test_id = config.test_id or f"PTEST-{str(uuid.uuid4())[:8]}"
        config.test_id = test_id
        
        self.test_configs[test_id] = config
        self.active_tests[test_id] = TestStatus.SCHEDULED
        
        print(f"✅ Created penetration test: {config.test_name}")
        print(f"   Test ID: {test_id}")
        print(f"   Scope: {len(config.target_networks)} networks, {len(config.target_domains)} domains")
        if config.scheduled_start:
            print(f"   Scheduled: {config.scheduled_start.strftime('%Y-%m-%d %H:%M')}")
        
        return test_id
    
    async def execute_test(self, test_id: str, dry_run: bool = False) -> Optional[TestResults]:
        """
        Execute complete penetration test.
        
        Args:
            test_id: Test to execute
            dry_run: If True, simulate without actual exploitation
            
        Returns:
            Test results
        """
        
        if test_id not in self.test_configs:
            print(f"❌ Test {test_id} not found")
            return None
        
        config = self.test_configs[test_id]
        
        # Initialize results
        results = TestResults(
            test_id=test_id,
            start_time=datetime.now()
        )
        
        self.active_tests[test_id] = TestStatus.RUNNING
        self._trigger_event('test_started', {'test_id': test_id, 'config': config})
        
        print(f"\n{'='*70}")
        print(f"🎯 EXECUTING PENETRATION TEST: {config.test_name}")
        print(f"{'='*70}\n")
        
        try:
            # Phase 1: Reconnaissance
            await self._phase_reconnaissance(config, results, dry_run)
            
            # Phase 2: Attack Simulation
            if config.network_testing:
                await self._phase_attack_simulation(config, results, dry_run)
            
            # Phase 3: Social Engineering
            if config.social_engineering and config.phishing_enabled:
                await self._phase_social_engineering(config, results, dry_run)
            
            # Phase 4: Results Analysis
            await self._phase_results_analysis(config, results)
            
            # Phase 5: Report Generation
            await self._phase_report_generation(config, results)
            
            # Mark as completed
            results.end_time = datetime.now()
            results.duration_minutes = (results.end_time - results.start_time).total_seconds() / 60
            
            self.test_results[test_id] = results
            self.active_tests[test_id] = TestStatus.COMPLETED
            
            self._trigger_event('test_completed', {'test_id': test_id, 'results': results})
            
            print(f"\n{'='*70}")
            print(f"✅ PENETRATION TEST COMPLETED")
            print(f"{'='*70}\n")
            print(f"Duration: {results.duration_minutes:.1f} minutes")
            print(f"Success Rate: {results.attack_chain_success_rate:.1f}%")
            print(f"Systems Compromised: {results.systems_compromised}")
            
            return results
            
        except Exception as e:
            print(f"\n❌ Test execution failed: {e}")
            self.active_tests[test_id] = TestStatus.FAILED
            return None
    
    async def _phase_reconnaissance(
        self,
        config: TestConfiguration,
        results: TestResults,
        dry_run: bool
    ) -> None:
        """Execute reconnaissance phase"""
        
        print(f"📡 Phase 1: RECONNAISSANCE")
        print(f"{'='*70}\n")
        
        print(f"   🔍 Scanning target networks...")
        for network in config.target_networks:
            print(f"      - {network}")
        
        print(f"   🌐 Enumerating domains...")
        for domain in config.target_domains:
            print(f"      - {domain}")
        
        # Simulate discovery
        import random
        results.critical_vulns = random.randint(1, 5)
        results.high_vulns = random.randint(3, 10)
        results.medium_vulns = random.randint(5, 15)
        results.low_vulns = random.randint(10, 30)
        
        print(f"\n   ✅ Reconnaissance complete")
        print(f"      Found: {results.critical_vulns} critical, {results.high_vulns} high vulnerabilities")
        
        self._trigger_event('phase_completed', {'phase': 'reconnaissance', 'results': results})
        
        await asyncio.sleep(1)  # Simulate work
    
    async def _phase_attack_simulation(
        self,
        config: TestConfiguration,
        results: TestResults,
        dry_run: bool
    ) -> None:
        """Execute attack simulation phase"""
        
        print(f"\n⚔️  Phase 2: ATTACK SIMULATION")
        print(f"{'='*70}\n")
        
        if not self.attack_simulator:
            print("   ⚠️  Attack simulator not available")
            return
        
        print(f"   🎭 Emulating APT Group: {config.apt_group}")
        
        # Create attack chain
        try:
            apt_group = APTGroup[config.apt_group.upper().replace('-', '_')]
        except:
            apt_group = APTGroup.APT29
        
        attack_chain = self.attack_simulator.create_attack_chain(
            name=f"{config.test_name} - Attack Chain",
            apt_group=apt_group,
            target_description=f"Targets: {', '.join(config.target_domains[:3])}",
            tactics=config.attack_tactics if config.attack_tactics else None
        )
        
        print(f"   🔗 Created attack chain: {len(attack_chain.steps)} steps")
        
        # Execute attack chain
        self.attack_simulator.execute_attack_chain(
            attack_chain,
            dry_run=True,  # Always dry run for safety
            stop_on_detection=False
        )
        
        # Get metrics
        report = self.attack_simulator.get_attack_report(attack_chain.chain_id)
        
        results.attack_chain_success_rate = report['metrics']['success_rate']
        results.attack_chain_detection_rate = report['metrics']['detection_rate']
        results.techniques_executed = report['metrics']['total_techniques']
        results.techniques_successful = report['metrics']['successful_techniques']
        results.systems_compromised = len(config.target_networks) if results.attack_chain_success_rate > 50 else 0
        
        print(f"\n   ✅ Attack simulation complete")
        print(f"      Success Rate: {results.attack_chain_success_rate:.1f}%")
        print(f"      Detection Rate: {results.attack_chain_detection_rate:.1f}%")
        
        self._trigger_event('phase_completed', {'phase': 'attack_simulation', 'results': results})
        
        await asyncio.sleep(2)
    
    async def _phase_social_engineering(
        self,
        config: TestConfiguration,
        results: TestResults,
        dry_run: bool
    ) -> None:
        """Execute social engineering phase"""
        
        print(f"\n🎣 Phase 3: SOCIAL ENGINEERING")
        print(f"{'='*70}\n")
        
        if not self.social_engineering:
            print("   ⚠️  Social engineering module not available")
            return
        
        if not config.phishing_targets:
            print("   ℹ️  No phishing targets configured")
            return
        
        print(f"   📧 Launching phishing campaign")
        print(f"   Targets: {len(config.phishing_targets)} employees")
        
        # Create campaign
        campaign = self.social_engineering.create_campaign(
            name=f"{config.test_name} - Phishing",
            campaign_type=CampaignType.PHISHING,
            template_id="TMPL-PASSWORD-RESET",
            landing_page_id="PAGE-MS365",
            targets=config.phishing_targets,
            launch_date=datetime.now()
        )
        
        if campaign:
            # Launch campaign (simulation)
            self.social_engineering.launch_campaign(campaign.campaign_id, gophish_integration=False)
            
            # Get metrics
            metrics = self.social_engineering.get_campaign_metrics(campaign.campaign_id)
            
            results.phishing_sent = metrics['emails_sent']
            results.phishing_opened = metrics['emails_opened']
            results.phishing_clicked = metrics['links_clicked']
            results.phishing_compromised = metrics['data_submitted']
            
            print(f"\n   ✅ Social engineering complete")
            print(f"      Opened: {metrics['rates']['open_rate']:.1f}%")
            print(f"      Clicked: {metrics['rates']['click_rate']:.1f}%")
            print(f"      Compromised: {metrics['rates']['compromise_rate']:.1f}%")
        
        self._trigger_event('phase_completed', {'phase': 'social_engineering', 'results': results})
        
        await asyncio.sleep(2)
    
    async def _phase_results_analysis(
        self,
        config: TestConfiguration,
        results: TestResults
    ) -> None:
        """Analyze test results"""
        
        print(f"\n📊 Phase 4: RESULTS ANALYSIS")
        print(f"{'='*70}\n")
        
        print(f"   🔍 Analyzing findings...")
        
        # Aggregate data accessed
        if results.systems_compromised > 0:
            results.data_accessed = [
                "Customer database (PII)",
                "Financial records",
                "Employee credentials",
                "Configuration files"
            ]
        
        print(f"   ✅ Analysis complete")
        
        await asyncio.sleep(1)
    
    async def _phase_report_generation(
        self,
        config: TestConfiguration,
        results: TestResults
    ) -> None:
        """Generate executive reports"""
        
        print(f"\n📋 Phase 5: REPORT GENERATION")
        print(f"{'='*70}\n")
        
        if not self.roi_generator:
            print("   ⚠️  ROI generator not available")
            return
        
        print(f"   📝 Generating executive report...")
        
        # Add findings to ROI generator
        if results.critical_vulns > 0:
            finding = SecurityFinding(
                finding_id=f"{results.test_id}-CRIT-001",
                title="Critical vulnerabilities in production environment",
                description=f"Discovered {results.critical_vulns} critical vulnerabilities",
                risk_level=RiskLevel.CRITICAL,
                cvss_score=9.0,
                affected_systems=results.systems_compromised,
                potential_loss=2_000_000,
                remediation_cost=100_000
            )
            self.roi_generator.add_finding(finding)
        
        # Add metrics
        metrics = SecurityMetrics(
            critical_vulns=results.critical_vulns,
            high_vulns=results.high_vulns,
            medium_vulns=results.medium_vulns,
            low_vulns=results.low_vulns,
            phishing_success_rate=(results.phishing_compromised / results.phishing_sent * 100) if results.phishing_sent > 0 else 0
        )
        self.roi_generator.add_metrics(metrics)
        
        print(f"   ✅ Reports generated")
        
        await asyncio.sleep(1)
    
    def get_test_status(self, test_id: str) -> Dict[str, Any]:
        """Get current test status"""
        
        if test_id not in self.test_configs:
            return {'error': 'Test not found'}
        
        config = self.test_configs[test_id]
        status = self.active_tests.get(test_id, TestStatus.SCHEDULED)
        results = self.test_results.get(test_id)
        
        return {
            'test_id': test_id,
            'test_name': config.test_name,
            'status': status.value,
            'scheduled_start': config.scheduled_start.isoformat() if config.scheduled_start else None,
            'results': {
                'duration_minutes': results.duration_minutes if results else 0,
                'success_rate': results.attack_chain_success_rate if results else 0,
                'systems_compromised': results.systems_compromised if results else 0
            } if results else None
        }
    
    def register_event_handler(self, event_type: str, handler: Callable) -> None:
        """Register event handler"""
        
        if event_type in self.event_handlers:
            self.event_handlers[event_type].append(handler)
    
    def _trigger_event(self, event_type: str, data: Dict[str, Any]) -> None:
        """Trigger event handlers"""
        
        if event_type in self.event_handlers:
            for handler in self.event_handlers[event_type]:
                try:
                    handler(data)
                except Exception as e:
                    print(f"⚠️  Event handler error: {e}")
    
    def generate_comprehensive_report(self, test_id: str) -> Dict[str, Any]:
        """Generate comprehensive test report"""
        
        if test_id not in self.test_results:
            return {'error': 'Test results not found'}
        
        config = self.test_configs[test_id]
        results = self.test_results[test_id]
        
        # Get ROI analysis
        if self.roi_generator:
            dashboard = self.roi_generator.generate_executive_dashboard()
            roi = self.roi_generator.calculate_roi(investment_amount=500_000)
        else:
            dashboard = {}
            roi = {}
        
        report = {
            'test_summary': {
                'test_id': test_id,
                'test_name': config.test_name,
                'duration_minutes': results.duration_minutes,
                'start_time': results.start_time.isoformat() if results.start_time else None,
                'end_time': results.end_time.isoformat() if results.end_time else None
            },
            'attack_simulation': {
                'success_rate': f"{results.attack_chain_success_rate:.1f}%",
                'detection_rate': f"{results.attack_chain_detection_rate:.1f}%",
                'techniques_executed': results.techniques_executed,
                'systems_compromised': results.systems_compromised
            },
            'social_engineering': {
                'emails_sent': results.phishing_sent,
                'opened_rate': f"{(results.phishing_opened / results.phishing_sent * 100) if results.phishing_sent > 0 else 0:.1f}%",
                'clicked_rate': f"{(results.phishing_clicked / results.phishing_sent * 100) if results.phishing_sent > 0 else 0:.1f}%",
                'compromise_rate': f"{(results.phishing_compromised / results.phishing_sent * 100) if results.phishing_sent > 0 else 0:.1f}%"
            },
            'vulnerabilities': {
                'critical': results.critical_vulns,
                'high': results.high_vulns,
                'medium': results.medium_vulns,
                'low': results.low_vulns,
                'total': results.critical_vulns + results.high_vulns + results.medium_vulns + results.low_vulns
            },
            'business_impact': {
                'systems_compromised': results.systems_compromised,
                'data_accessed': results.data_accessed
            },
            'roi_analysis': roi,
            'executive_dashboard': dashboard
        }
        
        return report


# Example usage
if __name__ == "__main__":
    import asyncio
    
    print("\n" + "="*70)
    print("Penetration Testing Orchestration System")
    print("="*70 + "\n")
    
    # Initialize orchestrator
    orchestrator = PentestOrchestrator()
    
    # Create test configuration
    config = TestConfiguration(
        test_id="PTEST-2024-001",
        test_name="Q4 2024 Enterprise Security Assessment",
        target_networks=["10.0.0.0/24", "192.168.1.0/24"],
        target_domains=["internal.company.com", "app.company.com"],
        target_applications=["Customer Portal", "Admin Dashboard"],
        network_testing=True,
        web_app_testing=True,
        social_engineering=True,
        apt_group="APT29",
        phishing_enabled=True,
        phishing_targets=[
            {'email': 'john@company.com', 'first_name': 'John', 'last_name': 'Doe'},
            {'email': 'jane@company.com', 'first_name': 'Jane', 'last_name': 'Smith'},
        ],
        notification_emails=["security@company.com"]
    )
    
    # Create test
    test_id = orchestrator.create_test(config)
    
    # Execute test
    async def run_test():
        results = await orchestrator.execute_test(test_id, dry_run=True)
        
        if results:
            print("\n" + "="*70)
            print("📊 COMPREHENSIVE REPORT")
            print("="*70 + "\n")
            
            report = orchestrator.generate_comprehensive_report(test_id)
            print(json.dumps(report, indent=2))
    
    # Run
    asyncio.run(run_test())
